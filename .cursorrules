# Reticle - Sniper Training App Architecture Rules

## Technology Stack
- **Framework**: React Native (Expo) with expo-router for navigation
- **Authentication**: Supabase Auth (email/password + OAuth)
- **Database**: Supabase PostgreSQL with Row Level Security (RLS)
- **State Management**: Zustand stores
- **External API**: FastAPI detection service

---

## Core Architectural Principles

### 1. AUTHENTICATION & DATA ACCESS PATTERN

**ALWAYS follow this flow:**
```
Component/Hook
  → Service Layer (services/*.ts)
    → AuthenticatedClient.getClient() (automatic token injection)
      → Supabase Client with JWT
        → Database + RLS Policies
```

**Authentication Setup:**
```typescript
// contexts/AuthContext.tsx provides auth state
import { useAuth } from '@/contexts/AuthContext'

const { user, session, loading, signIn, signOut } = useAuth()
const userId = user?.id  // UUID from auth.users table
```

**Rules:**
- NEVER pass tokens as parameters to service functions
- NEVER create Supabase clients directly in components or hooks
- ALWAYS use `AuthenticatedClient.getClient()` in service layer
- Token injection is automatic - services don't need to know about auth
- Use `user.id` for user UUID (not Clerk's userId pattern)

**Example:**
```typescript
// ✅ CORRECT - Service layer
export async function getSessionsService(userId: string, orgId?: string) {
  const client = await AuthenticatedClient.getClient(); // Auto token injection
  return client.from("session_stats").select("*").eq("created_by", userId);
}

// ✅ CORRECT - Component usage
const { user } = useAuth();
const sessions = await getSessionsService(user.id, orgId);

// ❌ WRONG - Don't pass tokens
getSessionsService(token, userId, orgId); // DEPRECATED

// ❌ WRONG - Don't create clients in components
const client = await getAuthenticatedClient(); // Bypass service layer
```

---

### 2. FILE ORGANIZATION STRUCTURE

```
/services/           → Database access layer (Supabase queries)
/store/             → Zustand state management
/hooks/             → Custom React hooks
/components/
  /modals/          → Modal dialogs
  /ui/              → Reusable UI primitives (buttons, inputs)
  /forms/           → Form components
  /organizations/   → Organization-specific components
/modules/           → Feature modules (complete features)
  /[feature]/
    /components/    → Feature UI components
    /hooks/         → Feature-specific hooks
    /types/         → Feature-specific types
/contexts/          → React contexts (Auth, Theme, etc.)
/types/             → Global type definitions
  database.ts       → Generated Supabase types
  api.ts            → API request/response types
/lib/               → Core utilities (authenticatedClient, supabase config)
```

---

### 3. SERVICE LAYER RULES

**Location:** `/services/*.ts`

**Purpose:**
- Encapsulate ALL database operations
- Provide clean API for data access
- Handle authentication automatically
- Implement consistent error handling

**Structure:**
```typescript
// services/[entity]Service.ts

import { AuthenticatedClient } from "@/lib/authenticatedClient";
import { DatabaseError } from "@/lib/errors";
import type { Entity, CreateEntityInput, UpdateEntityInput } from "@/types/database";

/**
 * Get entities with optional filtering
 * @param userId - Current user ID (UUID from auth.users)
 * @param orgId - Optional organization ID (UUID) for org context
 */
export async function getEntitiesService(
  userId: string,
  orgId?: string
): Promise<Entity[]> {
  const client = await AuthenticatedClient.getClient();

  let query = client.from("entities").select("*");

  // Context-based filtering
  if (orgId) {
    query = query.eq("organization_id", orgId);
  } else {
    query = query.eq("created_by", userId);
  }

  const { data, error } = await query;

  if (error) throw new DatabaseError(error.message);
  return data || [];
}

/**
 * Create a new entity
 */
export async function createEntityService(
  input: CreateEntityInput,
  userId: string,
  orgId?: string
): Promise<Entity> {
  const client = await AuthenticatedClient.getClient();

  const { data, error } = await client
    .from("entities")
    .insert({
      ...input,
      created_by: userId,
      organization_id: orgId || null,
    })
    .select()
    .single();

  if (error) throw new DatabaseError(error.message);
  return data;
}

/**
 * Update an entity (partial update)
 */
export async function updateEntityService(
  entityId: string,
  input: UpdateEntityInput
): Promise<Entity> {
  const client = await AuthenticatedClient.getClient();

  const { data, error } = await client
    .from("entities")
    .update(input)
    .eq("id", entityId)
    .select()
    .single();

  if (error) throw new DatabaseError(error.message);
  return data;
}

/**
 * Delete an entity
 */
export async function deleteEntityService(entityId: string): Promise<void> {
  const client = await AuthenticatedClient.getClient();

  const { error } = await client
    .from("entities")
    .delete()
    .eq("id", entityId);

  if (error) throw new DatabaseError(error.message);
}
```

**Naming Convention:**
- File: `[entity]Service.ts` (e.g., `sessionService.ts`, `weaponsService.ts`)
- Functions: `[action][Entity]Service` (e.g., `getSessionsService`, `createLoadoutService`)

**DO:**
- ✅ Use TypeScript types for all parameters and returns
- ✅ Include JSDoc comments explaining parameters
- ✅ Throw custom error types (DatabaseError, NotFoundError, etc.)
- ✅ Use async/await (never callbacks)
- ✅ Validate required parameters
- ✅ Return clean, typed data

**DON'T:**
- ❌ Accept token parameters (authentication is automatic)
- ❌ Mix business logic with database queries (keep pure)
- ❌ Use `any` types
- ❌ Catch errors silently (let them bubble up)
- ❌ Access environment variables directly (use lib/supabase.ts)

---

### 4. STATE MANAGEMENT RULES (ZUSTAND STORES)

**Location:** `/store/[entity]Store.ts`

**When to create a store:**
- Multiple components need the same data
- Need optimistic updates (UI updates before server confirms)
- Complex state management (sorting, filtering, pagination)
- Want centralized error/loading state

**Structure:**
```typescript
// store/entitiesStore.ts

import { create } from "zustand";
import { getEntitiesService, createEntityService, updateEntityService, deleteEntityService } from "@/services/entityService";
import type { Entity, CreateEntityInput, UpdateEntityInput } from "@/types/database";

interface EntitiesStore {
  // State
  entities: Entity[];
  loading: boolean;
  error: string | null;

  // Actions
  fetchEntities: (userId: string, orgId?: string) => Promise<void>;
  createEntity: (input: CreateEntityInput, userId: string, orgId?: string) => Promise<void>;
  updateEntity: (entityId: string, input: UpdateEntityInput) => Promise<void>;
  deleteEntity: (entityId: string) => Promise<void>;
  resetEntities: () => void;
}

export const entitiesStore = create<EntitiesStore>((set, get) => ({
  // Initial state
  entities: [],
  loading: false,
  error: null,

  // Fetch all entities
  fetchEntities: async (userId: string, orgId?: string) => {
    set({ loading: true, error: null });
    try {
      const entities = await getEntitiesService(userId, orgId);
      set({ entities, loading: false });
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
  },

  // Create entity with optimistic update
  createEntity: async (input: CreateEntityInput, userId: string, orgId?: string) => {
    set({ loading: true, error: null });
    try {
      const newEntity = await createEntityService(input, userId, orgId);
      set((state) => ({
        entities: [newEntity, ...state.entities], // Prepend to array
        loading: false,
      }));
    } catch (error: any) {
      set({ error: error.message, loading: false });
      throw error; // Re-throw for component error handling
    }
  },

  // Update entity in place
  updateEntity: async (entityId: string, input: UpdateEntityInput) => {
    set({ loading: true, error: null });
    try {
      const updated = await updateEntityService(entityId, input);
      set((state) => ({
        entities: state.entities.map((e) =>
          e.id === entityId ? updated : e
        ),
        loading: false,
      }));
    } catch (error: any) {
      set({ error: error.message, loading: false });
      throw error;
    }
  },

  // Delete entity
  deleteEntity: async (entityId: string) => {
    set({ loading: true, error: null });
    try {
      await deleteEntityService(entityId);
      set((state) => ({
        entities: state.entities.filter((e) => e.id !== entityId),
        loading: false,
      }));
    } catch (error: any) {
      set({ error: error.message, loading: false });
      throw error;
    }
  },

  // Reset state (on logout, context switch)
  resetEntities: () => set({ entities: [], loading: false, error: null }),
}));
```

**Store Naming:**
- File: `[entity]Store.ts` (singular if one entity, plural if collection)
- Export: `export const entityStore = create<EntityStore>(...)`

**Store Usage in Components:**
```typescript
import { useStore } from "zustand";
import { entitiesStore } from "@/store/entitiesStore";
import { useAuth } from "@/contexts/AuthContext";

export function MyComponent() {
  const { entities, loading, error, fetchEntities } = useStore(entitiesStore);
  const { user } = useAuth();

  useEffect(() => {
    if (user?.id) {
      fetchEntities(user.id, orgId);
    }
  }, [user?.id, orgId]);

  if (loading) return <Spinner />;
  if (error) return <ErrorView message={error} />;

  return <ListView data={entities} />;
}
```

**DO:**
- ✅ Keep stores focused on single entity/domain
- ✅ Use optimistic updates for better UX
- ✅ Call service layer functions (never direct DB access)
- ✅ Handle loading/error states consistently
- ✅ Provide reset functions for cleanup

**DON'T:**
- ❌ Put business logic in stores (keep in services)
- ❌ Create giant "god stores" with everything
- ❌ Access stores outside React components (use getState() sparingly)
- ❌ Forget to handle errors

---

### 5. CONTEXT-BASED DATA FILTERING

**Personal vs Organization Context:**

Every user operates in one of two contexts:
1. **Personal Context** (`orgId = null | undefined`): User's personal data only
2. **Organization Context** (`orgId = UUID`): Organization shared data

**Implementation Pattern:**
```typescript
export async function getEntitiesService(
  userId: string,
  orgId?: string,
  additionalFilter?: string
): Promise<Entity[]> {
  const client = await AuthenticatedClient.getClient();

  let query = client.from("entities").select("*");

  if (orgId) {
    // ORGANIZATION CONTEXT: Get all entities in this org
    query = query.eq("organization_id", orgId);
  } else {
    // PERSONAL CONTEXT: Get only entities created by this user
    query = query.eq("created_by", userId).is("organization_id", null);
  }

  if (additionalFilter) {
    query = query.eq("status", additionalFilter);
  }

  const { data, error } = await query;
  if (error) throw new DatabaseError(error.message);
  return data || [];
}
```

**Rules:**
- ALWAYS check for `orgId` to determine context
- Document context behavior in JSDoc
- Use consistent filtering pattern across all services
- RLS policies enforce permissions at database level

---

### 6. DATABASE SCHEMA CONVENTIONS

**Table Structure:**
```sql
CREATE TABLE entities (
  -- Primary key
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Multi-tenancy (Supabase Auth UUIDs)
  organization_id uuid REFERENCES organizations(id),  -- Nullable for personal items
  created_by uuid NOT NULL REFERENCES auth.users(id),  -- User ID (always required)

  -- Foreign keys
  parent_id uuid REFERENCES parents(id) ON DELETE CASCADE,

  -- Data columns
  name text NOT NULL,
  description text,
  status text CHECK (status IN ('active', 'inactive')),
  metadata jsonb,

  -- Audit columns (always include)
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

-- Always create updated_at trigger
CREATE TRIGGER update_entities_updated_at
  BEFORE UPDATE ON entities
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Always create indexes for foreign keys
CREATE INDEX idx_entities_organization_id ON entities(organization_id);
CREATE INDEX idx_entities_created_by ON entities(created_by);
CREATE INDEX idx_entities_parent_id ON entities(parent_id);
```

**RLS Policy Pattern:**
```sql
-- Enable RLS
ALTER TABLE entities ENABLE ROW LEVEL SECURITY;

-- SELECT: Can see own items OR items in same org
CREATE POLICY "Users can view entities"
  ON entities FOR SELECT
  USING (
    created_by = auth.uid()  -- auth.uid() returns the authenticated user's UUID
    OR (
      organization_id IS NOT NULL
      AND EXISTS (
        SELECT 1 FROM org_memberships
        WHERE user_id = auth.uid()
        AND org_id = entities.organization_id
      )
    )
  );

-- INSERT: Can only create for self in current org
CREATE POLICY "Users can create entities"
  ON entities FOR INSERT
  WITH CHECK (
    created_by = auth.uid()
    AND (organization_id IS NULL OR EXISTS (
      SELECT 1 FROM org_memberships
      WHERE user_id = auth.uid()
      AND org_id = entities.organization_id
    ))
  );

-- UPDATE/DELETE: Can only modify own items
CREATE POLICY "Users can update own entities"
  ON entities FOR UPDATE
  USING (created_by = auth.uid());

CREATE POLICY "Users can delete own entities"
  ON entities FOR DELETE
  USING (created_by = auth.uid());
```

---

### 7. AUTHENTICATION SETUP

**Supabase Auth Provider:**
```typescript
// contexts/AuthContext.tsx
import { supabase } from '@/lib/supabase'
import { User, Session } from '@supabase/supabase-js'

interface AuthContextType {
  user: User | null           // Supabase User object
  session: Session | null     // Supabase Session with access_token
  loading: boolean
  signUp: (email: string, password: string) => Promise<void>
  signIn: (email: string, password: string) => Promise<void>
  signInWithOAuth: (provider: 'google' | 'apple') => Promise<void>
  signOut: () => Promise<void>
}

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [user, setUser] = useState<User | null>(null)
  const [session, setSession] = useState<Session | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    // Get initial session
    supabase.auth.getSession().then(({ data: { session } }) => {
      setSession(session)
      setUser(session?.user ?? null)
      setLoading(false)
    })

    // Listen for auth changes
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setSession(session)
      setUser(session?.user ?? null)
      setLoading(false)
    })

    return () => subscription.unsubscribe()
  }, [])

  // Initialize AuthenticatedClient with token provider
  useEffect(() => {
    AuthenticatedClient.initialize(async () => {
      const { data: { session } } = await supabase.auth.getSession()
      return session?.access_token ?? ''
    })
  }, [])

  // ... signIn, signOut, etc.
}
```

**Usage:**
```typescript
import { useAuth } from '@/contexts/AuthContext'

const { user, session, loading, signIn, signOut } = useAuth()
const userId = user?.id  // UUID from auth.users
```

---

### 8. ERROR HANDLING STANDARDS

**Custom Error Types:**
```typescript
// lib/errors.ts

export class ServiceError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ServiceError";
  }
}

export class AuthenticationError extends ServiceError {
  constructor(message: string) {
    super(message);
    this.name = "AuthenticationError";
  }
}

export class DatabaseError extends ServiceError {
  constructor(message: string) {
    super(message);
    this.name = "DatabaseError";
  }
}

export class NotFoundError extends ServiceError {
  constructor(message: string) {
    super(message);
    this.name = "NotFoundError";
  }
}

export class ValidationError extends ServiceError {
  constructor(message: string) {
    super(message);
    this.name = "ValidationError";
  }
}

export class NetworkError extends ServiceError {
  constructor(message: string) {
    super(message);
    this.name = "NetworkError";
  }
}

export class PermissionError extends ServiceError {
  constructor(message: string) {
    super(message);
    this.name = "PermissionError";
  }
}
```

**Error Handling Pattern:**
```typescript
// In services
try {
  const { data, error } = await client.from("entities").select();
  if (error) throw new DatabaseError(error.message);
  return data;
} catch (error) {
  if (error instanceof ServiceError) throw error;
  if (error.name === "TypeError") throw new NetworkError("Connection failed");
  throw new DatabaseError("Unknown database error");
}

// In stores
try {
  const data = await getEntitiesService(userId, orgId);
  set({ entities: data, loading: false });
} catch (err: any) {
  console.error("Error fetching entities:", err);
  set({ error: err.message, entities: [], loading: false });
}

// In components
try {
  await createEntity(input, userId, orgId);
  Alert.alert("Success", "Entity created");
} catch (error: any) {
  if (error instanceof ValidationError) {
    Alert.alert("Validation Error", error.message);
  } else if (error instanceof PermissionError) {
    Alert.alert("Permission Denied", "You don't have access");
  } else {
    Alert.alert("Error", "Something went wrong");
  }
}
```

---

### 9. TYPE SAFETY RULES

**Database Types:**
```typescript
// types/database.ts - Generated from Supabase

export type Database = {
  public: {
    Tables: {
      entities: {
        Row: Entity; // SELECT return type
        Insert: CreateEntityInput; // INSERT input type
        Update: UpdateEntityInput; // UPDATE input type
      };
    };
  };
};

export type Entity = Database["public"]["Tables"]["entities"]["Row"];
export type CreateEntityInput = Database["public"]["Tables"]["entities"]["Insert"];
export type UpdateEntityInput = Database["public"]["Tables"]["entities"]["Update"];
```

**Generate types after migrations:**
```bash
npx supabase gen types typescript --project-id <project-id> > types/database.ts
```

**DO:**
- ✅ Always generate types from database schema
- ✅ Use strict TypeScript mode
- ✅ Define interfaces for all props
- ✅ Use enums for fixed values
- ✅ Never use `any` (use `unknown` if truly needed)

---

### 10. NAMING CONVENTIONS

**Files:**
- Components: PascalCase (`EntityList.tsx`)
- Hooks: camelCase with `use` prefix (`useEntities.ts`)
- Services: camelCase with `Service` suffix (`entityService.ts`)
- Stores: camelCase with `Store` suffix (`entitiesStore.ts`)
- Types: camelCase (`database.ts`, `api.ts`)
- Constants: camelCase (`colors.ts`)

**Variables:**
- Components: PascalCase (`const EntityList = () => {}`)
- Functions: camelCase (`function getEntities()`)
- Constants: SCREAMING_SNAKE_CASE for true constants (`const API_URL`)
- State variables: camelCase (`const [entities, setEntities]`)

**Database:**
- Tables: snake_case, plural (`user_loadouts`, `weapon_models`)
- Columns: snake_case (`created_by`, `organization_id`)
- Indexes: `idx_[table]_[column]` (`idx_sessions_organization_id`)

---

### 11. FORBIDDEN PATTERNS (DON'T DO THIS)

❌ **Passing tokens to services:**
```typescript
// DON'T
getSessionsService(token, userId, orgId);
```

❌ **Direct Supabase client in components:**
```typescript
// DON'T
const client = await getAuthenticatedClient();
const { data } = await client.from("sessions").select();
```

❌ **Business logic in components:**
```typescript
// DON'T
const handleCreate = async () => {
  const client = await getAuthenticatedClient();
  const { data } = await client.from("sessions").insert({ ... });
  // ... lots of logic
};
```

❌ **Mixed patterns (direct DB + service layer):**
```typescript
// DON'T - Pick one pattern
const sessions = await getSessionsService(userId); // Service
const trainings = await client.from("trainings").select(); // Direct
```

❌ **Ignoring errors:**
```typescript
// DON'T
try {
  await createEntity();
} catch (error) {
  // Silent failure
}
```

❌ **Using `any` types:**
```typescript
// DON'T
function processData(data: any) { ... }
```

❌ **Giant god stores:**
```typescript
// DON'T
const appStore = create(() => ({
  sessions: [],
  trainings: [],
  users: [],
  organizations: [],
  // ... everything
}));
```

---

### 12. MIGRATION CHECKLIST

When adding a new feature:

**1. Database Schema** (`supabase/migrations/[timestamp]_[name].sql`)
- [ ] Create table with proper columns
- [ ] Add `organization_id` and `created_by` columns (UUIDs)
- [ ] Add `created_at` and `updated_at` with trigger
- [ ] Add foreign key constraints with `ON DELETE CASCADE`
- [ ] Create indexes for foreign keys
- [ ] Enable RLS
- [ ] Add RLS policies (SELECT, INSERT, UPDATE, DELETE)
- [ ] Add seed data if needed (`supabase/seed.sql`)

**2. Generate Types**
- [ ] Run `npx supabase gen types` to update `types/database.ts`

**3. Service Layer** (`services/[entity]Service.ts`)
- [ ] Create `get[Entity]Service(userId, orgId)`
- [ ] Create `create[Entity]Service(input, userId, orgId)`
- [ ] Create `update[Entity]Service(id, input)`
- [ ] Create `delete[Entity]Service(id)`
- [ ] Add JSDoc comments
- [ ] Add error handling
- [ ] Export all functions

**4. State Management** (`store/[entity]Store.ts`)
- [ ] Define state interface
- [ ] Create Zustand store
- [ ] Add `fetch`, `create`, `update`, `delete` actions
- [ ] Add `reset` action
- [ ] Add loading/error handling
- [ ] Call service functions

**5. Components** (`modules/[feature]/components/`)
- [ ] Create feature components
- [ ] Use stores or hooks for data
- [ ] Handle loading/error states
- [ ] Add proper TypeScript types

**6. Test**
- [ ] Test personal context (no orgId)
- [ ] Test organization context (with orgId)
- [ ] Test RLS policies work correctly
- [ ] Test error handling

---

## Summary

**Golden Rules:**
1. Services handle ALL database operations
2. AuthenticatedClient automatically injects tokens
3. Stores manage shared state, hooks for component-specific
4. RLS policies enforce permissions at database level
5. Context-based filtering (personal vs organization)
6. Strong TypeScript types throughout
7. Consistent error handling with custom error types
8. Follow migration checklist for new features

**Authentication Pattern:**
- Use `useAuth()` hook from `contexts/AuthContext.tsx`
- User ID: `user.id` (UUID from `auth.users`)
- RLS uses `auth.uid()` to identify current user
- Organization context via UUID references (not `org_xxx` format)

**When in doubt:**
- Refer to existing patterns in `sessionService.ts`, `sessionsStore.ts`
- Use service layer pattern consistently
- Keep components simple and focused
- Let RLS handle permission enforcement
- Test both personal and organization contexts

