diff --git a/node_modules/react-native-garmin-connect/ios/AppConstants.swift b/node_modules/react-native-garmin-connect/ios/AppConstants.swift
index 2e67eb2..3ba78f5 100644
--- a/node_modules/react-native-garmin-connect/ios/AppConstants.swift
+++ b/node_modules/react-native-garmin-connect/ios/AppConstants.swift
@@ -8,7 +8,9 @@ struct AppConstants {
     static let MESSAGE_TYPE_CURRENT_ANGLE = "MESSAGE_TYPE_CURRENT_ANGLE"
     static let MESSAGE_TYPE_MAX_ANGLE = "MESSAGE_TYPE_MAX_ANGLE"
 
-    static let APP_ID = "467f4bb7-cd3c-45c4-a39b-9bb78260c9ed"
+    // This can be set at runtime via GarminDeviceStorage.appId
+    // Default is empty - set your ConnectIQ watch app UUID
+    static var APP_ID: String = "bd8df375-4ed5-4ff3-bcf4-b752426e1628"
 
     static let STATUS_ONLINE = "ONLINE"
     static let STATUS_OFFLINE = "OFFLINE"
diff --git a/node_modules/react-native-garmin-connect/ios/GarminConnect.h b/node_modules/react-native-garmin-connect/ios/GarminConnect.h
index 9d6604f..ce4c4a6 100644
--- a/node_modules/react-native-garmin-connect/ios/GarminConnect.h
+++ b/node_modules/react-native-garmin-connect/ios/GarminConnect.h
@@ -1,14 +1,18 @@
 #import <React/RCTEventEmitter.h>
-#import "GarminConnectModule.h"
 #import <Foundation/Foundation.h>
 
+#if __has_include(<React/RCTBridgeModule.h>)
+#import <React/RCTBridgeModule.h>
+#endif
+
+@class GarminConnectModule;
+
 #ifdef RCT_NEW_ARCH_ENABLED
 
 #import "NativeGarminConnect.h"
 
 @interface GarminConnect : RCTEventEmitter<NativeGarminConnectSpec>
 #else
-#import <React/RCTBridgeModule.h>
 @interface GarminConnect : RCTEventEmitter<RCTBridgeModule>
 #endif
 @property (strong, nonatomic) GarminConnectModule *garminConnect;
diff --git a/node_modules/react-native-garmin-connect/ios/GarminConnectModule.h b/node_modules/react-native-garmin-connect/ios/GarminConnectModule.h
index 07c2959..99bec8e 100644
--- a/node_modules/react-native-garmin-connect/ios/GarminConnectModule.h
+++ b/node_modules/react-native-garmin-connect/ios/GarminConnectModule.h
@@ -1,4 +1,4 @@
-#import "ConnectIQ.h"
+#import <ConnectIQ/ConnectIQ.h>
 #import "React/RCTEventEmitter.h"
 
 @interface GarminConnectModule : NSObject <IQAppMessageDelegate, IQDeviceEventDelegate>
diff --git a/node_modules/react-native-garmin-connect/ios/GarminConnectModule.swift b/node_modules/react-native-garmin-connect/ios/GarminConnectModule.swift
index 46e8be4..baf5ee1 100644
--- a/node_modules/react-native-garmin-connect/ios/GarminConnectModule.swift
+++ b/node_modules/react-native-garmin-connect/ios/GarminConnectModule.swift
@@ -21,7 +21,7 @@ public class GarminConnectModule: NSObject, IQDeviceEventDelegate, IQAppMessageD
         self.onSdkReady()
     }
 
-    @objc func destroy(){
+    @objc public func destroy(){
         ConnectIQ.sharedInstance().unregister(forAllDeviceEvents: self)
         ConnectIQ.sharedInstance().unregister(forAllAppMessages: self)
     }
@@ -39,13 +39,77 @@ public class GarminConnectModule: NSObject, IQDeviceEventDelegate, IQAppMessageD
 
     @objc(connectDevice:model:name:)
     public func connectDevice(id: String, model: String, name: String) {
-        let device = IQDevice.init(id: UUID(uuidString: id), modelName: model, friendlyName: name)
+        // Get LIVE IQDevice from current session - archived devices don't work!
+        guard let device = GarminDeviceStorage.getDevice(byId: id) else {
+            print("[Garmin] âŒ Device \(id) not in current session - needs re-pairing via GCM")
+            // Emit status indicating re-pairing is needed
+            let errorDevice: NSMutableDictionary = [:]
+            errorDevice["name"] = name
+            errorDevice["status"] = "OFFLINE"
+            errorDevice["needsRepairing"] = true
+            errorDevice["error"] = "Session expired. Tap to re-pair via Garmin Connect."
+            self.emitter.sendEvent(withName: "onDeviceStatusChanged", body: errorDevice)
+            return
+        }
+
+        print("[Garmin] âœ… Connecting to live session device: \(device.friendlyName ?? name)")
+
         ConnectIQ.sharedInstance().register(forDeviceEvents: device, delegate: self)
+
+        // Query and emit the current device status immediately
+        let currentStatus = ConnectIQ.sharedInstance().getDeviceStatus(device)
+        let (statusStr, reason) = getStatus(status: currentStatus)
+        print("[Garmin] Device \(name) status: \(statusStr) (\(reason))")
+        self.onDeviceStatusChanged(device, status: statusStr, reason: reason)
+
+        // If already connected, register for app messages
+        if currentStatus == .connected {
+            connectedApp = IQApp(uuid: watchAppUuid, store: nil, device: device)
+            ConnectIQ.sharedInstance().register(forAppMessages: connectedApp, delegate: self)
+            print("[Garmin] Registered for app messages with app UUID: \(AppConstants.APP_ID)")
+        }
     }
 
     @objc public func sendMessage(_ message: String) {
-        if let currentApp = connectedApp {
-            ConnectIQ.sharedInstance().sendMessage(message, to: currentApp, progress: nil, completion: nil)
+        print("[Garmin] ðŸ“¤ sendMessage called with: \(message)")
+        
+        guard let currentApp = connectedApp else {
+            print("[Garmin] âŒ connectedApp is nil - is watch app open?")
+            DispatchQueue.main.async {
+                self.emitter.sendEvent(withName: "onError", body: "Watch app not connected. Open the app on your watch.")
+            }
+            return
+        }
+        
+        print("[Garmin] ðŸ“¤ Have connected app, parsing message...")
+        
+        var messageDict: [String: Any]
+        
+        if let data = message.data(using: .utf8),
+           let dict = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
+            messageDict = dict
+        } else {
+            messageDict = [
+                "type": "DATA",
+                "payload": ["text": message]
+            ]
+        }
+        
+        print("[Garmin] ðŸ“¤ Sending message dict: \(messageDict)")
+        
+        // Use completion handler to catch any errors
+        ConnectIQ.sharedInstance().sendMessage(messageDict, to: currentApp, progress: nil) { [weak self] (result: IQSendMessageResult) in
+            let resultString = NSStringFromSendMessageResult(result)
+            print("[Garmin] ðŸ“¤ sendMessage completion: \(resultString)")
+            
+            if result == .success {
+                print("[Garmin] âœ… Message sent successfully")
+            } else {
+                print("[Garmin] âŒ Message send failed: \(resultString)")
+                DispatchQueue.main.async {
+                    self?.emitter.sendEvent(withName: "onError", body: "Send failed: \(resultString)")
+                }
+            }
         }
     } 
 
@@ -53,19 +117,27 @@ public class GarminConnectModule: NSObject, IQDeviceEventDelegate, IQAppMessageD
         self.emitter.sendEvent(withName: "onInfo", body: "Garmin Connect app is required.")
     }
 
-    func getStatus(status: IQDeviceStatus) -> String {
+    func getStatus(status: IQDeviceStatus) -> (status: String, reason: String) {
         switch status {
             case .connected:
-                return "CONNECTED"
+                return ("CONNECTED", "connected")
             case .notConnected:
-                return "ONLINE"
-        case .bluetoothNotReady, .invalidDevice, .notFound:
-                return "OFFLINE"
+                return ("ONLINE", "notConnected - watch reachable but app not open")
+            case .bluetoothNotReady:
+                return ("OFFLINE", "bluetoothNotReady - turn on Bluetooth")
+            case .invalidDevice:
+                return ("OFFLINE", "invalidDevice - re-pair required")
+            case .notFound:
+                return ("OFFLINE", "notFound - open Garmin Connect Mobile")
+            @unknown default:
+                return ("OFFLINE", "unknown")
         }
     }
 
     public func deviceStatusChanged(_ device: IQDevice!, status: IQDeviceStatus) {
-        self.onDeviceStatusChanged(device, status: getStatus(status: status))
+        let (statusStr, reason) = getStatus(status: status)
+        print("[Garmin] Device status callback: \(statusStr) (\(reason))")
+        self.onDeviceStatusChanged(device, status: statusStr, reason: reason)
         switch status {
             case .connected:
                 connectedApp = IQApp(uuid: watchAppUuid, store: nil, device: device)
@@ -77,45 +149,116 @@ public class GarminConnectModule: NSObject, IQDeviceEventDelegate, IQAppMessageD
     }
 
     public func receivedMessage(_ messages: Any!, from app: IQApp!) {
-        if let messagesArray = messages as? [NSMutableDictionary] {
-            for message in messagesArray {
-                self.onMessage(body: message)
+        // TEMPORARY: Just log and ignore to test if this is the crash source
+        print("[Garmin] ðŸ“© RECEIVED MESSAGE - IGNORING FOR DEBUG")
+        print("[Garmin] ðŸ“© Type: \(type(of: messages))")
+        
+        // Do nothing else - if app still crashes, it's not this function
+    }
+    
+    private func processReceivedMessage(_ messages: Any!) throws {
+        print("[Garmin] ðŸ“© DEBUG: processReceivedMessage called")
+        
+        guard messages != nil else {
+            print("[Garmin] âš ï¸ DEBUG: messages is nil")
+            return
+        }
+        
+        if let messagesArray = messages as? [[String: Any]] {
+            print("[Garmin] ðŸ“© DEBUG: Processing as [[String: Any]] with \(messagesArray.count) items")
+            for (index, message) in messagesArray.enumerated() {
+                print("[Garmin] ðŸ“© DEBUG: Processing item \(index)")
+                self.processMessage(message)
+            }
+        } else if let messagesArray = messages as? [Any] {
+            print("[Garmin] ðŸ“© DEBUG: Processing as [Any] with \(messagesArray.count) items")
+            for (index, message) in messagesArray.enumerated() {
+                print("[Garmin] ðŸ“© DEBUG: Processing item \(index), type: \(type(of: message))")
+                if let dict = message as? [String: Any] {
+                    self.processMessage(dict)
+                } else {
+                    self.emitSafeMessage(type: "RAW", payload: String(describing: message))
+                }
             }
+        } else if let message = messages as? [String: Any] {
+            print("[Garmin] ðŸ“© DEBUG: Processing as [String: Any]")
+            self.processMessage(message)
+        } else {
+            print("[Garmin] âš ï¸ DEBUG: Unknown format, wrapping as string")
+            self.emitSafeMessage(type: "RAW", payload: String(describing: messages!))
         }
-        else if let message = messages as? NSMutableDictionary {
-            print("Received message from ConnectIQ: \(message)")
-                // just one message
-            self.onMessage(body: message)
+    }
+    
+    private func processMessage(_ body: [String: Any]) {
+        print("[Garmin] ðŸ“¨ DEBUG: processMessage with body: \(body)")
+        
+        let messageType = (body["type"] as? String) 
+            ?? (body[AppConstants.KEY_MESSAGE_TYPE] as? String) 
+            ?? "UNKNOWN"
+        print("[Garmin] ðŸ“¨ DEBUG: messageType = \(messageType)")
+        
+        // Convert payload to string safely
+        var payloadString = ""
+        
+        if let payload = body["payload"] ?? body[AppConstants.KEY_MESSAGE_PAYLOAD] ?? body["data"] {
+            print("[Garmin] ðŸ“¨ DEBUG: payload type = \(type(of: payload))")
+            
+            if let dict = payload as? [String: Any] {
+                if JSONSerialization.isValidJSONObject(dict),
+                   let data = try? JSONSerialization.data(withJSONObject: dict, options: []),
+                   let str = String(data: data, encoding: .utf8) {
+                    payloadString = str
+                } else {
+                    payloadString = String(describing: dict)
+                }
+            } else if let str = payload as? String {
+                payloadString = str
+            } else if let num = payload as? NSNumber {
+                payloadString = num.stringValue
+            } else {
+                payloadString = String(describing: payload)
+            }
         }
-     }
         
-    func onSdkReady() {
-        self.emitter.sendEvent(withName: "onSdkReady", body: true)
+        print("[Garmin] ðŸ“¨ DEBUG: payloadString = \(payloadString)")
+        self.emitSafeMessage(type: messageType, payload: payloadString)
     }
     
-    func onMessage(body: NSMutableDictionary) {
-        let message: NSMutableDictionary = [:]
-        message["type"] = body[AppConstants.KEY_MESSAGE_TYPE]
-        let payload = body[AppConstants.KEY_MESSAGE_PAYLOAD]
+    private func emitSafeMessage(type: String, payload: String) {
+        print("[Garmin] ðŸ“¤ DEBUG: emitSafeMessage type=\(type) payload=\(payload)")
         
-        let payloadData = try? JSONSerialization.data(withJSONObject: payload!, options: [])
-        if let unwrappedPayloadData = payloadData {
-            let payloadString = String(data: unwrappedPayloadData, encoding: String.Encoding.ascii)!
-            message["payload"] = payloadString;
-        }
+        // Only use simple types that are guaranteed to be serializable
+        let eventMessage: [String: String] = [
+            "type": type,
+            "payload": payload
+        ]
         
-        self.emitter.sendEvent(withName: "onMessage", body: message)
+        print("[Garmin] ðŸ“¤ DEBUG: About to emit...")
+        self.emitter.sendEvent(withName: "onMessage", body: eventMessage)
+        print("[Garmin] ðŸ“¤ DEBUG: Emit complete!")
     }
 
-    func onError(error: NSString) {
-        self.emitter.sendEvent(withName: "onError", body: error)
+    func onSdkReady() {
+        DispatchQueue.main.async {
+            print("[Garmin] âœ… DEBUG: Emitting onSdkReady")
+            self.emitter.sendEvent(withName: "onSdkReady", body: true)
+        }
     }
 
+    func onError(error: NSString) {
+        DispatchQueue.main.async {
+            self.emitter.sendEvent(withName: "onError", body: error)
+        }
+    }
 
-    func onDeviceStatusChanged(_ device: IQDevice, status: String) {
+    func onDeviceStatusChanged(_ device: IQDevice, status: String, reason: String) {
         let deviceObject: NSMutableDictionary = [:]
         deviceObject["name"] = device.friendlyName
         deviceObject["status"] = status
-        self.emitter.sendEvent(withName: "onDeviceStatusChanged", body: deviceObject)
+        deviceObject["reason"] = reason  // Why this status (for debugging)
+        
+        DispatchQueue.main.async {
+            self.emitter.sendEvent(withName: "onDeviceStatusChanged", body: deviceObject)
+        }
     }
 }
diff --git a/node_modules/react-native-garmin-connect/ios/GarminDeviceStorage.swift b/node_modules/react-native-garmin-connect/ios/GarminDeviceStorage.swift
index a7c6f2d..f39ed5e 100644
--- a/node_modules/react-native-garmin-connect/ios/GarminDeviceStorage.swift
+++ b/node_modules/react-native-garmin-connect/ios/GarminDeviceStorage.swift
@@ -1,30 +1,82 @@
-
 import Foundation
+import ConnectIQ
 
 @objc(GarminDeviceStorage)
 public class GarminDeviceStorage: NSObject {
-    static var urlScheme = ""
+    static var urlScheme = "retic"
+    static var appId = "bd8df375-4ed5-4ff3-bcf4-b752426e1628"
     static var devicesListKey = "devicesListKey"
 
+    // IMPORTANT: IQDevice objects are SESSION-BASED and cannot be persisted!
+    // Only devices from the CURRENT session's parseDeviceSelectionResponse are valid.
+    // This cache holds live IQDevice objects from the current app session only.
+    private static var sessionDevices: [String: IQDevice] = [:]
+
     @objc
-    public static func onDevicesReceived(open url: URL){
-
-        if (url.scheme == urlScheme){
-            let devices = ConnectIQ.sharedInstance()?.parseDeviceSelectionResponse(from: url) as? [IQDevice]
-            var devicesToSet: [Data] = []
-            
-            if let unwrappedDevices = devices {
-                for device in unwrappedDevices {
-                    let garminDevice = GarminDevice(id: device.uuid.uuidString, model: device.modelName, name: device.friendlyName)
-                    let result = try? JSONEncoder().encode(garminDevice)
-                    if let unwrappedDevice = result {
-                        devicesToSet.append(unwrappedDevice)
-                    }
+    public static func onDevicesReceived(open url: URL) {
+        print("[Garmin] URL received: \(url.absoluteString)")
+        print("[Garmin] URL scheme: \(url.scheme ?? "nil"), expected: \(urlScheme)")
+        print("[Garmin] URL host: \(url.host ?? "nil")")
+        print("[Garmin] URL path: \(url.path)")
+        print("[Garmin] URL query: \(url.query ?? "nil")")
+
+        // Check if this is the device selection response from GCM
+        let isDeviceSelectResp = url.path == "/device-select-resp" ||
+                                  url.host == "device-select-resp" ||
+                                  (url.query?.contains("devices") ?? false)
+
+        guard url.scheme == urlScheme && isDeviceSelectResp else {
+            print("[Garmin] Not a device selection response, ignoring")
+            return
+        }
+
+        print("[Garmin] Processing device selection response...")
+
+        // Parse fresh IQDevice objects from GCM - these are the ONLY valid device references
+        let devices = ConnectIQ.sharedInstance()?.parseDeviceSelectionResponse(from: url) as? [IQDevice]
+        print("[Garmin] Parsed \(devices?.count ?? 0) fresh devices from GCM")
+
+        var devicesToStore: [Data] = []
+        
+        // Clear previous session devices
+        sessionDevices.removeAll()
+
+        if let unwrappedDevices = devices {
+            for device in unwrappedDevices {
+                // Store device INFO for display (UUID, name, model) - NOT the IQDevice object
+                let garminDevice = GarminDevice(id: device.uuid.uuidString, model: device.modelName, name: device.friendlyName)
+                if let result = try? JSONEncoder().encode(garminDevice) {
+                    devicesToStore.append(result)
                 }
+
+                // Cache the LIVE IQDevice object for this session only
+                sessionDevices[device.uuid.uuidString] = device
+                print("[Garmin] âœ… Fresh device cached: \(device.friendlyName ?? "Unknown") - \(device.uuid.uuidString)")
             }
+        }
+
+        // Persist only the display info (not IQDevice objects - they can't be restored)
+        UserDefaults.standard.set(devicesToStore, forKey: devicesListKey)
+        print("[Garmin] Stored \(sessionDevices.count) session devices")
+    }
 
-            UserDefaults.standard.set(devicesToSet, forKey: devicesListKey)
+    // Get a LIVE IQDevice object - only works for current session devices
+    @objc
+    public static func getDevice(byId id: String) -> IQDevice? {
+        if let device = sessionDevices[id] {
+            print("[Garmin] âœ… Found live session device: \(id)")
+            return device
         }
+        
+        // Device not in current session - user needs to re-pair via GCM
+        print("[Garmin] âŒ Device \(id) not in current session - re-pairing required")
+        return nil
+    }
+    
+    // Check if we have live session devices
+    @objc
+    public static func hasSessionDevices() -> Bool {
+        return !sessionDevices.isEmpty
     }
 
     static func getDevicesList(_ resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
@@ -39,12 +91,17 @@ public class GarminDeviceStorage: NSObject {
                     deviceObject["id"] = unwrappedDevice.id
                     deviceObject["name"] = unwrappedDevice.name
                     deviceObject["model"] = unwrappedDevice.model
-                    deviceObject["status"] = "ONLINE"
+                    
+                    // Check if this device has a live session reference
+                    let hasLiveSession = sessionDevices[unwrappedDevice.id] != nil
+                    deviceObject["status"] = hasLiveSession ? "ONLINE" : "OFFLINE"
+                    deviceObject["needsRepairing"] = !hasLiveSession
+                    
                     devicesList.add(deviceObject)
                 }
             }
         }
 
-        resolve(devicesList);
+        resolve(devicesList)
     }
 }
diff --git a/node_modules/react-native-garmin-connect/react-native-garmin-connect.podspec b/node_modules/react-native-garmin-connect/react-native-garmin-connect.podspec
index 16e7390..602c195 100644
--- a/node_modules/react-native-garmin-connect/react-native-garmin-connect.podspec
+++ b/node_modules/react-native-garmin-connect/react-native-garmin-connect.podspec
@@ -14,7 +14,8 @@ Pod::Spec.new do |s|
   s.platforms    = { :ios => min_ios_version_supported }
   s.source       = { :git => "https://github.com/malgorzatamaz/react-native-garmin-connect.git", :tag => "#{s.version}" }
 
-  s.source_files = "ios/**/*.{h,m,mm,swift}"
+  s.source_files = "ios/*.{h,m,mm,swift}"
+  s.public_header_files = "ios/GarminConnect.h"
   s.vendored_frameworks = 'ios/ConnectIQ.xcframework'
 
   # Use install_modules_dependencies helper to install the dependencies if React Native version >=0.71.0.
diff --git a/node_modules/react-native-garmin-connect/src/index.tsx b/node_modules/react-native-garmin-connect/src/index.tsx
index d72b4a2..99887f2 100644
--- a/node_modules/react-native-garmin-connect/src/index.tsx
+++ b/node_modules/react-native-garmin-connect/src/index.tsx
@@ -29,7 +29,6 @@ const LINKING_ERROR =
   '- You rebuilt the app after installing the package\n' +
   '- You are not using Expo Go\n';
 
-// @ts-expect-error
 const isTurboModuleEnabled = global.__turboModuleProxy != null;
 
 const GarminConnectModule = isTurboModuleEnabled
