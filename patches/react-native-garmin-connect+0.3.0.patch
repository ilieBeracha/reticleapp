diff --git a/node_modules/react-native-garmin-connect/ios/AppConstants.swift b/node_modules/react-native-garmin-connect/ios/AppConstants.swift
index 2e67eb2..3ba78f5 100644
--- a/node_modules/react-native-garmin-connect/ios/AppConstants.swift
+++ b/node_modules/react-native-garmin-connect/ios/AppConstants.swift
@@ -8,7 +8,9 @@ struct AppConstants {
     static let MESSAGE_TYPE_CURRENT_ANGLE = "MESSAGE_TYPE_CURRENT_ANGLE"
     static let MESSAGE_TYPE_MAX_ANGLE = "MESSAGE_TYPE_MAX_ANGLE"
 
-    static let APP_ID = "467f4bb7-cd3c-45c4-a39b-9bb78260c9ed"
+    // This can be set at runtime via GarminDeviceStorage.appId
+    // Default is empty - set your ConnectIQ watch app UUID
+    static var APP_ID: String = "bd8df3754ed54ff3bcf4b752426e1628"
 
     static let STATUS_ONLINE = "ONLINE"
     static let STATUS_OFFLINE = "OFFLINE"
diff --git a/node_modules/react-native-garmin-connect/ios/GarminConnect.h b/node_modules/react-native-garmin-connect/ios/GarminConnect.h
index 9d6604f..ce4c4a6 100644
--- a/node_modules/react-native-garmin-connect/ios/GarminConnect.h
+++ b/node_modules/react-native-garmin-connect/ios/GarminConnect.h
@@ -1,14 +1,18 @@
 #import <React/RCTEventEmitter.h>
-#import "GarminConnectModule.h"
 #import <Foundation/Foundation.h>
 
+#if __has_include(<React/RCTBridgeModule.h>)
+#import <React/RCTBridgeModule.h>
+#endif
+
+@class GarminConnectModule;
+
 #ifdef RCT_NEW_ARCH_ENABLED
 
 #import "NativeGarminConnect.h"
 
 @interface GarminConnect : RCTEventEmitter<NativeGarminConnectSpec>
 #else
-#import <React/RCTBridgeModule.h>
 @interface GarminConnect : RCTEventEmitter<RCTBridgeModule>
 #endif
 @property (strong, nonatomic) GarminConnectModule *garminConnect;
diff --git a/node_modules/react-native-garmin-connect/ios/GarminConnectModule.h b/node_modules/react-native-garmin-connect/ios/GarminConnectModule.h
index 07c2959..99bec8e 100644
--- a/node_modules/react-native-garmin-connect/ios/GarminConnectModule.h
+++ b/node_modules/react-native-garmin-connect/ios/GarminConnectModule.h
@@ -1,4 +1,4 @@
-#import "ConnectIQ.h"
+#import <ConnectIQ/ConnectIQ.h>
 #import "React/RCTEventEmitter.h"
 
 @interface GarminConnectModule : NSObject <IQAppMessageDelegate, IQDeviceEventDelegate>
diff --git a/node_modules/react-native-garmin-connect/ios/GarminConnectModule.swift b/node_modules/react-native-garmin-connect/ios/GarminConnectModule.swift
index 46e8be4..b829fed 100644
--- a/node_modules/react-native-garmin-connect/ios/GarminConnectModule.swift
+++ b/node_modules/react-native-garmin-connect/ios/GarminConnectModule.swift
@@ -21,7 +21,7 @@ public class GarminConnectModule: NSObject, IQDeviceEventDelegate, IQAppMessageD
         self.onSdkReady()
     }
 
-    @objc func destroy(){
+    @objc public func destroy(){
         ConnectIQ.sharedInstance().unregister(forAllDeviceEvents: self)
         ConnectIQ.sharedInstance().unregister(forAllAppMessages: self)
     }
@@ -39,15 +39,58 @@ public class GarminConnectModule: NSObject, IQDeviceEventDelegate, IQAppMessageD
 
     @objc(connectDevice:model:name:)
     public func connectDevice(id: String, model: String, name: String) {
-        let device = IQDevice.init(id: UUID(uuidString: id), modelName: model, friendlyName: name)
+        // Get LIVE IQDevice from current session - archived devices don't work!
+        guard let device = GarminDeviceStorage.getDevice(byId: id) else {
+            print("[Garmin] ❌ Device \(id) not in current session - needs re-pairing via GCM")
+            // Emit status indicating re-pairing is needed
+            let errorDevice: NSMutableDictionary = [:]
+            errorDevice["name"] = name
+            errorDevice["status"] = "OFFLINE"
+            errorDevice["needsRepairing"] = true
+            errorDevice["error"] = "Session expired. Tap to re-pair via Garmin Connect."
+            self.emitter.sendEvent(withName: "onDeviceStatusChanged", body: errorDevice)
+            return
+        }
+
+        print("[Garmin] ✅ Connecting to live session device: \(device.friendlyName ?? name)")
+
         ConnectIQ.sharedInstance().register(forDeviceEvents: device, delegate: self)
+
+        // Query and emit the current device status immediately
+        let currentStatus = ConnectIQ.sharedInstance().getDeviceStatus(device)
+        print("[Garmin] Device \(name) current status: \(getStatus(status: currentStatus))")
+        self.onDeviceStatusChanged(device, status: getStatus(status: currentStatus))
+
+        // If already connected, register for app messages
+        if currentStatus == .connected {
+            connectedApp = IQApp(uuid: watchAppUuid, store: nil, device: device)
+            ConnectIQ.sharedInstance().register(forAppMessages: connectedApp, delegate: self)
+            print("[Garmin] Registered for app messages with app UUID: \(AppConstants.APP_ID)")
+        }
     }
 
-    @objc public func sendMessage(_ message: String) {
-        if let currentApp = connectedApp {
-            ConnectIQ.sharedInstance().sendMessage(message, to: currentApp, progress: nil, completion: nil)
+   @objc public func sendMessage(_ message: String) {
+    print("[Garmin] sendMessage called with: \(message)")
+    
+    if let currentApp = connectedApp {
+        print("[Garmin] Have connected app, sending...")        // Parse JSON string to Dictionary
+        if let data = message.data(using: .utf8),
+           let dict = try? JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
+            ConnectIQ.sharedInstance().sendMessage(dict, to: currentApp, progress: nil, completion: nil)
+        } else {
+            // Fallback: send as plain string wrapped in expected format
+            let wrappedMessage: [String: Any] = [
+                "type": "DATA",
+                "payload": ["text": message]
+            ]
+            ConnectIQ.sharedInstance().sendMessage(wrappedMessage, to: currentApp, progress: nil, completion: nil)
         }
     }
+    else {
+        print("[Garmin] ❌ connectedApp is nil - is watch app open?")
+        self.emitter.sendEvent(withName: "onError", body: "Watch app not connected. Open the app on your watch.")
+    }
+} 
 
     public func needsToInstallConnectMobile(){
         self.emitter.sendEvent(withName: "onInfo", body: "Garmin Connect app is required.")
@@ -56,10 +99,22 @@ public class GarminConnectModule: NSObject, IQDeviceEventDelegate, IQAppMessageD
     func getStatus(status: IQDeviceStatus) -> String {
         switch status {
             case .connected:
+                print("[Garmin] Status: .connected")
                 return "CONNECTED"
             case .notConnected:
+                print("[Garmin] Status: .notConnected (device reachable but app not running)")
                 return "ONLINE"
-        case .bluetoothNotReady, .invalidDevice, .notFound:
+            case .bluetoothNotReady:
+                print("[Garmin] Status: .bluetoothNotReady - Bluetooth may be off or unavailable")
+                return "OFFLINE"
+            case .invalidDevice:
+                print("[Garmin] Status: .invalidDevice - Device object is invalid/stale")
+                return "OFFLINE"
+            case .notFound:
+                print("[Garmin] Status: .notFound - Device not found via GCM")
+                return "OFFLINE"
+            @unknown default:
+                print("[Garmin] Status: unknown")
                 return "OFFLINE"
         }
     }
diff --git a/node_modules/react-native-garmin-connect/ios/GarminDeviceStorage.swift b/node_modules/react-native-garmin-connect/ios/GarminDeviceStorage.swift
index a7c6f2d..f39ed5e 100644
--- a/node_modules/react-native-garmin-connect/ios/GarminDeviceStorage.swift
+++ b/node_modules/react-native-garmin-connect/ios/GarminDeviceStorage.swift
@@ -1,30 +1,82 @@
-
 import Foundation
+import ConnectIQ
 
 @objc(GarminDeviceStorage)
 public class GarminDeviceStorage: NSObject {
-    static var urlScheme = ""
+    static var urlScheme = "retic"
+    static var appId = "bd8df375-4ed5-4ff3-bcf4-b752426e1628"
     static var devicesListKey = "devicesListKey"
 
+    // IMPORTANT: IQDevice objects are SESSION-BASED and cannot be persisted!
+    // Only devices from the CURRENT session's parseDeviceSelectionResponse are valid.
+    // This cache holds live IQDevice objects from the current app session only.
+    private static var sessionDevices: [String: IQDevice] = [:]
+
     @objc
-    public static func onDevicesReceived(open url: URL){
-
-        if (url.scheme == urlScheme){
-            let devices = ConnectIQ.sharedInstance()?.parseDeviceSelectionResponse(from: url) as? [IQDevice]
-            var devicesToSet: [Data] = []
-            
-            if let unwrappedDevices = devices {
-                for device in unwrappedDevices {
-                    let garminDevice = GarminDevice(id: device.uuid.uuidString, model: device.modelName, name: device.friendlyName)
-                    let result = try? JSONEncoder().encode(garminDevice)
-                    if let unwrappedDevice = result {
-                        devicesToSet.append(unwrappedDevice)
-                    }
+    public static func onDevicesReceived(open url: URL) {
+        print("[Garmin] URL received: \(url.absoluteString)")
+        print("[Garmin] URL scheme: \(url.scheme ?? "nil"), expected: \(urlScheme)")
+        print("[Garmin] URL host: \(url.host ?? "nil")")
+        print("[Garmin] URL path: \(url.path)")
+        print("[Garmin] URL query: \(url.query ?? "nil")")
+
+        // Check if this is the device selection response from GCM
+        let isDeviceSelectResp = url.path == "/device-select-resp" ||
+                                  url.host == "device-select-resp" ||
+                                  (url.query?.contains("devices") ?? false)
+
+        guard url.scheme == urlScheme && isDeviceSelectResp else {
+            print("[Garmin] Not a device selection response, ignoring")
+            return
+        }
+
+        print("[Garmin] Processing device selection response...")
+
+        // Parse fresh IQDevice objects from GCM - these are the ONLY valid device references
+        let devices = ConnectIQ.sharedInstance()?.parseDeviceSelectionResponse(from: url) as? [IQDevice]
+        print("[Garmin] Parsed \(devices?.count ?? 0) fresh devices from GCM")
+
+        var devicesToStore: [Data] = []
+        
+        // Clear previous session devices
+        sessionDevices.removeAll()
+
+        if let unwrappedDevices = devices {
+            for device in unwrappedDevices {
+                // Store device INFO for display (UUID, name, model) - NOT the IQDevice object
+                let garminDevice = GarminDevice(id: device.uuid.uuidString, model: device.modelName, name: device.friendlyName)
+                if let result = try? JSONEncoder().encode(garminDevice) {
+                    devicesToStore.append(result)
                 }
+
+                // Cache the LIVE IQDevice object for this session only
+                sessionDevices[device.uuid.uuidString] = device
+                print("[Garmin] ✅ Fresh device cached: \(device.friendlyName ?? "Unknown") - \(device.uuid.uuidString)")
             }
+        }
+
+        // Persist only the display info (not IQDevice objects - they can't be restored)
+        UserDefaults.standard.set(devicesToStore, forKey: devicesListKey)
+        print("[Garmin] Stored \(sessionDevices.count) session devices")
+    }
 
-            UserDefaults.standard.set(devicesToSet, forKey: devicesListKey)
+    // Get a LIVE IQDevice object - only works for current session devices
+    @objc
+    public static func getDevice(byId id: String) -> IQDevice? {
+        if let device = sessionDevices[id] {
+            print("[Garmin] ✅ Found live session device: \(id)")
+            return device
         }
+        
+        // Device not in current session - user needs to re-pair via GCM
+        print("[Garmin] ❌ Device \(id) not in current session - re-pairing required")
+        return nil
+    }
+    
+    // Check if we have live session devices
+    @objc
+    public static func hasSessionDevices() -> Bool {
+        return !sessionDevices.isEmpty
     }
 
     static func getDevicesList(_ resolve: RCTPromiseResolveBlock, reject: RCTPromiseRejectBlock) {
@@ -39,12 +91,17 @@ public class GarminDeviceStorage: NSObject {
                     deviceObject["id"] = unwrappedDevice.id
                     deviceObject["name"] = unwrappedDevice.name
                     deviceObject["model"] = unwrappedDevice.model
-                    deviceObject["status"] = "ONLINE"
+                    
+                    // Check if this device has a live session reference
+                    let hasLiveSession = sessionDevices[unwrappedDevice.id] != nil
+                    deviceObject["status"] = hasLiveSession ? "ONLINE" : "OFFLINE"
+                    deviceObject["needsRepairing"] = !hasLiveSession
+                    
                     devicesList.add(deviceObject)
                 }
             }
         }
 
-        resolve(devicesList);
+        resolve(devicesList)
     }
 }
diff --git a/node_modules/react-native-garmin-connect/react-native-garmin-connect.podspec b/node_modules/react-native-garmin-connect/react-native-garmin-connect.podspec
index 16e7390..602c195 100644
--- a/node_modules/react-native-garmin-connect/react-native-garmin-connect.podspec
+++ b/node_modules/react-native-garmin-connect/react-native-garmin-connect.podspec
@@ -14,7 +14,8 @@ Pod::Spec.new do |s|
   s.platforms    = { :ios => min_ios_version_supported }
   s.source       = { :git => "https://github.com/malgorzatamaz/react-native-garmin-connect.git", :tag => "#{s.version}" }
 
-  s.source_files = "ios/**/*.{h,m,mm,swift}"
+  s.source_files = "ios/*.{h,m,mm,swift}"
+  s.public_header_files = "ios/GarminConnect.h"
   s.vendored_frameworks = 'ios/ConnectIQ.xcframework'
 
   # Use install_modules_dependencies helper to install the dependencies if React Native version >=0.71.0.
diff --git a/node_modules/react-native-garmin-connect/src/index.tsx b/node_modules/react-native-garmin-connect/src/index.tsx
index d72b4a2..99887f2 100644
--- a/node_modules/react-native-garmin-connect/src/index.tsx
+++ b/node_modules/react-native-garmin-connect/src/index.tsx
@@ -29,7 +29,6 @@ const LINKING_ERROR =
   '- You rebuilt the app after installing the package\n' +
   '- You are not using Expo Go\n';
 
-// @ts-expect-error
 const isTurboModuleEnabled = global.__turboModuleProxy != null;
 
 const GarminConnectModule = isTurboModuleEnabled
