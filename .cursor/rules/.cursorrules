# Scopes Sniper Training App - Architecture Rules

## Technology Stack
- **Framework**: React Native (Expo) with expo-router for navigation
- **Authentication**: Clerk (OAuth provider with JWT tokens)
- **Database**: Supabase (PostgreSQL with Row Level Security)
- **State Management**: Zustand stores
- **External API**: FastAPI detection service

---

## Core Architectural Principles

### 1. AUTHENTICATION & DATA ACCESS PATTERN

**ALWAYS follow this flow:**
```
Component/Hook
  → Service Layer (services/*.ts)
    → AuthenticatedClient.getClient() (automatic token injection)
      → Supabase Client with JWT
        → Database + RLS Policies
```

**Rules:**
- NEVER pass tokens as parameters to service functions
- NEVER create Supabase clients directly in components or hooks
- ALWAYS use `AuthenticatedClient.getClient()` in service layer
- Token injection is automatic - services don't need to know about auth

**Example:**
```typescript
// ✅ CORRECT - Service layer
export async function getSessionsService(userId: string, orgId?: string) {
  const client = await AuthenticatedClient.getClient(); // Auto token injection
  return client.from("sessions").select("*").eq("created_by", userId);
}

// ✅ CORRECT - Component usage
const { userId, orgId } = useAuth();
const sessions = await getSessionsService(userId, orgId);

// ❌ WRONG - Don't pass tokens
getSessionsService(token, userId, orgId); // DEPRECATED

// ❌ WRONG - Don't create clients in components
const client = await getAuthenticatedClient(); // Bypass service layer
```

---

### 2. FILE ORGANIZATION STRUCTURE

```
/services/           → Database access layer (Supabase queries)
/store/             → Zustand state management
/hooks/
  /services/        → React hooks wrapping service functions
  /database/        → DEPRECATED - migrate to /services hooks
  /organizations/   → Clerk organization-specific hooks
/components/
  /modals/          → Modal dialogs
  /ui/              → Reusable UI primitives (buttons, inputs)
  /forms/           → Form components
  /[feature]/       → Feature-specific components
/modules/           → Feature modules (complete features)
  /[feature]/
    /components/    → Feature UI components
    /hooks/         → Feature-specific hooks
    /types/         → Feature-specific types
/types/             → Global type definitions
  database.ts       → Generated Supabase types
  api.ts            → API request/response types
/lib/               → Core utilities (authenticatedClient, supabase config)
```

---

### 3. SERVICE LAYER RULES

**Location:** `/services/*.ts`

**Purpose:**
- Encapsulate ALL database operations
- Provide clean API for data access
- Handle authentication automatically
- Implement consistent error handling

**Structure:**
```typescript
// services/[entity]Service.ts

import { AuthenticatedClient } from "@/lib/authenticatedClient";
import type { Entity, CreateEntityInput, UpdateEntityInput } from "@/types/database";

/**
 * Get entities with optional filtering
 * @param userId - Current user ID (from Clerk)
 * @param orgId - Optional organization ID for org context
 */
export async function getEntitiesService(
  userId: string,
  orgId?: string
): Promise<Entity[]> {
  const client = await AuthenticatedClient.getClient();

  let query = client.from("entities").select("*");

  // Context-based filtering
  if (orgId) {
    query = query.eq("organization_id", orgId);
  } else {
    query = query.eq("created_by", userId);
  }

  const { data, error } = await query;

  if (error) throw new DatabaseError(error.message);
  return data;
}

/**
 * Create a new entity
 */
export async function createEntityService(
  input: CreateEntityInput,
  userId: string,
  orgId: string
): Promise<Entity> {
  const client = await AuthenticatedClient.getClient();

  const { data, error } = await client
    .from("entities")
    .insert({
      ...input,
      created_by: userId,
      organization_id: orgId,
    })
    .select()
    .single();

  if (error) throw new DatabaseError(error.message);
  return data;
}

/**
 * Update an entity (partial update)
 */
export async function updateEntityService(
  entityId: string,
  input: UpdateEntityInput
): Promise<Entity> {
  const client = await AuthenticatedClient.getClient();

  const { data, error } = await client
    .from("entities")
    .update(input)
    .eq("id", entityId)
    .select()
    .single();

  if (error) throw new DatabaseError(error.message);
  return data;
}

/**
 * Delete an entity
 */
export async function deleteEntityService(entityId: string): Promise<void> {
  const client = await AuthenticatedClient.getClient();

  const { error } = await client
    .from("entities")
    .delete()
    .eq("id", entityId);

  if (error) throw new DatabaseError(error.message);
}
```

**Naming Convention:**
- File: `[entity]Service.ts` (e.g., `sessionService.ts`, `weaponsService.ts`)
- Functions: `[action][Entity]Service` (e.g., `getSessionsService`, `createLoadoutService`)

**DO:**
- ✅ Use TypeScript types for all parameters and returns
- ✅ Include JSDoc comments explaining parameters
- ✅ Throw custom error types (DatabaseError, NotFoundError, etc.)
- ✅ Use async/await (never callbacks)
- ✅ Validate required parameters
- ✅ Return clean, typed data

**DON'T:**
- ❌ Accept token parameters (authentication is automatic)
- ❌ Mix business logic with database queries (keep pure)
- ❌ Use `any` types
- ❌ Catch errors silently (let them bubble up)
- ❌ Access environment variables directly (use lib/supabase.ts)

---

### 4. STATE MANAGEMENT RULES (ZUSTAND STORES)

**Location:** `/store/[entity]Store.ts`

**When to create a store:**
- Multiple components need the same data
- Need optimistic updates (UI updates before server confirms)
- Complex state management (sorting, filtering, pagination)
- Want centralized error/loading state

**Structure:**
```typescript
// store/entitiesStore.ts

import { create } from "zustand";
import { getEntitiesService, createEntityService, updateEntityService, deleteEntityService } from "@/services/entityService";
import type { Entity, CreateEntityInput, UpdateEntityInput } from "@/types/database";

interface EntitiesStore {
  // State
  entities: Entity[];
  loading: boolean;
  error: string | null;

  // Actions
  fetchEntities: (userId: string, orgId?: string) => Promise<void>;
  createEntity: (input: CreateEntityInput, userId: string, orgId: string) => Promise<void>;
  updateEntity: (entityId: string, input: UpdateEntityInput) => Promise<void>;
  deleteEntity: (entityId: string) => Promise<void>;
  resetEntities: () => void;
}

export const entitiesStore = create<EntitiesStore>((set, get) => ({
  // Initial state
  entities: [],
  loading: false,
  error: null,

  // Fetch all entities
  fetchEntities: async (userId: string, orgId?: string) => {
    set({ loading: true, error: null });
    try {
      const entities = await getEntitiesService(userId, orgId);
      set({ entities, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  },

  // Create entity with optimistic update
  createEntity: async (input: CreateEntityInput, userId: string, orgId: string) => {
    set({ loading: true, error: null });
    try {
      const newEntity = await createEntityService(input, userId, orgId);
      set((state) => ({
        entities: [newEntity, ...state.entities], // Prepend to array
        loading: false,
      }));
    } catch (error) {
      set({ error: error.message, loading: false });
      throw error; // Re-throw for component error handling
    }
  },

  // Update entity in place
  updateEntity: async (entityId: string, input: UpdateEntityInput) => {
    set({ loading: true, error: null });
    try {
      const updated = await updateEntityService(entityId, input);
      set((state) => ({
        entities: state.entities.map((e) =>
          e.id === entityId ? updated : e
        ),
        loading: false,
      }));
    } catch (error) {
      set({ error: error.message, loading: false });
      throw error;
    }
  },

  // Delete entity
  deleteEntity: async (entityId: string) => {
    set({ loading: true, error: null });
    try {
      await deleteEntityService(entityId);
      set((state) => ({
        entities: state.entities.filter((e) => e.id !== entityId),
        loading: false,
      }));
    } catch (error) {
      set({ error: error.message, loading: false });
      throw error;
    }
  },

  // Reset state (on logout, context switch)
  resetEntities: () => set({ entities: [], loading: false, error: null }),
}));
```

**Store Naming:**
- File: `[entity]Store.ts` (singular if one entity, plural if collection)
- Export: `export const entityStore = create<EntityStore>(...)`

**Store Usage in Components:**
```typescript
import { useStore } from "zustand";
import { entitiesStore } from "@/store/entitiesStore";

export function MyComponent() {
  const { entities, loading, error, fetchEntities } = useStore(entitiesStore);
  const { userId, orgId } = useAuth();

  useEffect(() => {
    fetchEntities(userId, orgId);
  }, [userId, orgId]);

  if (loading) return <Spinner />;
  if (error) return <ErrorView message={error} />;

  return <ListView data={entities} />;
}
```

**DO:**
- ✅ Keep stores focused on single entity/domain
- ✅ Use optimistic updates for better UX
- ✅ Call service layer functions (never direct DB access)
- ✅ Handle loading/error states consistently
- ✅ Provide reset functions for cleanup

**DON'T:**
- ❌ Put business logic in stores (keep in services)
- ❌ Create giant "god stores" with everything
- ❌ Access stores outside React components (use getState() sparingly)
- ❌ Forget to handle errors

---

### 5. HOOK PATTERNS

#### Pattern A: Service Hooks (Recommended for Simple Queries)
**Location:** `/hooks/services/use[Entity].ts`

```typescript
// hooks/services/useEntities.ts

import { useState, useEffect } from "react";
import { getEntitiesService } from "@/services/entityService";
import { useAuth } from "@/hooks/useAuth";
import type { Entity } from "@/types/database";

export function useEntities(filter?: string) {
  const { userId, orgId } = useAuth();
  const [entities, setEntities] = useState<Entity[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const refetch = async () => {
    setLoading(true);
    setError(null);
    try {
      const data = await getEntitiesService(userId, orgId);
      setEntities(data);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    refetch();
  }, [userId, orgId, filter]);

  return { entities, loading, error, refetch };
}
```

**When to use:**
- Simple data fetching for single component
- Don't need to share state across components
- Read-only operations
- Want automatic dependency tracking

#### Pattern B: Store Hooks (For Shared State)
```typescript
// Just use the store directly
import { useStore } from "zustand";
import { entitiesStore } from "@/store/entitiesStore";

const { entities, loading, fetchEntities } = useStore(entitiesStore);
```

**When to use:**
- Multiple components need same data
- Need CRUD operations
- Want centralized state
- Need optimistic updates

#### Pattern C: Organization Hooks
**Location:** `/hooks/organizations/use[Feature].ts`

Clerk-specific hooks for organization management (existing pattern is good).

---

### 6. COMPONENT STRUCTURE RULES

#### Module Components (Feature Components)
**Location:** `/modules/[feature]/components/[Component].tsx`

```typescript
// modules/entities/components/EntityList.tsx

import { useStore } from "zustand";
import { entitiesStore } from "@/store/entitiesStore";
import { useAuth } from "@/hooks/useAuth";
import { ThemedView } from "@/components/Themed";
import { EntityItem } from "./EntityItem";

export function EntityList() {
  const { entities, loading, error, fetchEntities } = useStore(entitiesStore);
  const { userId, orgId } = useAuth();

  useEffect(() => {
    fetchEntities(userId, orgId);
  }, [userId, orgId]);

  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <ThemedView>
      {entities.map((entity) => (
        <EntityItem key={entity.id} entity={entity} />
      ))}
    </ThemedView>
  );
}
```

**Component Rules:**
- One component per file
- Use TypeScript interfaces for props
- Extract complex logic to hooks
- Keep components focused (single responsibility)
- Use `Themed*` components for consistent styling

#### Shared Components
**Location:** `/components/[category]/[Component].tsx`

Categories:
- `/components/ui/` - Primitives (buttons, inputs, text)
- `/components/modals/` - Modal dialogs
- `/components/forms/` - Form inputs
- `/components/[feature]/` - Reusable feature components

---

### 7. ERROR HANDLING STANDARDS

**Custom Error Types:**
```typescript
// lib/errors.ts (create this)

export class ServiceError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ServiceError";
  }
}

export class AuthenticationError extends ServiceError {
  constructor(message: string) {
    super(message);
    this.name = "AuthenticationError";
  }
}

export class DatabaseError extends ServiceError {
  constructor(message: string) {
    super(message);
    this.name = "DatabaseError";
  }
}

export class NotFoundError extends ServiceError {
  constructor(message: string) {
    super(message);
    this.name = "NotFoundError";
  }
}

export class ValidationError extends ServiceError {
  constructor(message: string) {
    super(message);
    this.name = "ValidationError";
  }
}

export class NetworkError extends ServiceError {
  constructor(message: string) {
    super(message);
    this.name = "NetworkError";
  }
}

export class PermissionError extends ServiceError {
  constructor(message: string) {
    super(message);
    this.name = "PermissionError";
  }
}
```

**Error Handling Pattern:**
```typescript
// In services
try {
  const { data, error } = await client.from("entities").select();
  if (error) throw new DatabaseError(error.message);
  return data;
} catch (error) {
  if (error instanceof ServiceError) throw error;
  if (error.name === "TypeError") throw new NetworkError("Connection failed");
  throw new DatabaseError("Unknown database error");
}

// In stores
try {
  const data = await getEntitiesService(userId, orgId);
  set({ entities: data, loading: false });
} catch (error) {
  set({ error: error.message, loading: false });
  // Optional: log to error tracking service
}

// In components
try {
  await createEntity(input, userId, orgId);
  Alert.alert("Success", "Entity created");
} catch (error) {
  if (error instanceof ValidationError) {
    Alert.alert("Validation Error", error.message);
  } else if (error instanceof PermissionError) {
    Alert.alert("Permission Denied", "You don't have access");
  } else {
    Alert.alert("Error", "Something went wrong");
  }
}
```

---

### 8. CONTEXT-BASED DATA FILTERING

**Personal vs Organization Context:**

Every user operates in one of two contexts:
1. **Personal Context** (`orgId = undefined`): User's personal data only
2. **Organization Context** (`orgId = "org_xxx"`): Organization shared data

**Implementation Pattern:**
```typescript
export async function getEntitiesService(
  userId: string,
  orgId?: string,
  additionalFilter?: string
): Promise<Entity[]> {
  const client = await AuthenticatedClient.getClient();

  let query = client.from("entities").select("*");

  if (orgId) {
    // ORGANIZATION CONTEXT: Get all entities in this org
    query = query.eq("organization_id", orgId);
  } else {
    // PERSONAL CONTEXT: Get only entities created by this user
    query = query.eq("created_by", userId);
  }

  if (additionalFilter) {
    query = query.eq("status", additionalFilter);
  }

  const { data, error } = await query;
  if (error) throw new DatabaseError(error.message);
  return data;
}
```

**Rules:**
- ALWAYS check for `orgId` to determine context
- Document context behavior in JSDoc
- Use consistent filtering pattern across all services
- RLS policies enforce permissions at database level

---

### 9. DATABASE SCHEMA CONVENTIONS

**Table Structure:**
```sql
CREATE TABLE entities (
  -- Primary key
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Multi-tenancy (Clerk IDs)
  organization_id text,  -- Clerk org_id (nullable for personal items)
  created_by text NOT NULL,  -- Clerk user_id (always required)

  -- Foreign keys
  parent_id uuid REFERENCES parents(id) ON DELETE CASCADE,

  -- Data columns
  name text NOT NULL,
  description text,
  status text CHECK (status IN ('active', 'inactive')),
  metadata jsonb,

  -- Audit columns (always include)
  created_at timestamptz DEFAULT now() NOT NULL,
  updated_at timestamptz DEFAULT now() NOT NULL
);

-- Always create updated_at trigger
CREATE TRIGGER update_entities_updated_at
  BEFORE UPDATE ON entities
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Always create indexes for foreign keys
CREATE INDEX idx_entities_organization_id ON entities(organization_id);
CREATE INDEX idx_entities_created_by ON entities(created_by);
CREATE INDEX idx_entities_parent_id ON entities(parent_id);
```

**RLS Policy Pattern:**
```sql
-- Enable RLS
ALTER TABLE entities ENABLE ROW LEVEL SECURITY;

-- SELECT: Can see own items OR items in same org
CREATE POLICY "Users can view entities"
  ON entities FOR SELECT
  USING (
    created_by = auth.jwt() ->> 'sub'
    OR organization_id = auth.jwt() ->> 'org_id'
  );

-- INSERT: Can only create for self in current org
CREATE POLICY "Users can create entities"
  ON entities FOR INSERT
  WITH CHECK (
    created_by = auth.jwt() ->> 'sub'
    AND (organization_id = auth.jwt() ->> 'org_id' OR organization_id IS NULL)
  );

-- UPDATE/DELETE: Can only modify own items
CREATE POLICY "Users can update own entities"
  ON entities FOR UPDATE
  USING (created_by = auth.jwt() ->> 'sub');

CREATE POLICY "Users can delete own entities"
  ON entities FOR DELETE
  USING (created_by = auth.jwt() ->> 'sub');
```

---

### 10. TYPE SAFETY RULES

**Database Types:**
```typescript
// types/database.ts - Generated from Supabase

export type Database = {
  public: {
    Tables: {
      entities: {
        Row: Entity; // SELECT return type
        Insert: CreateEntityInput; // INSERT input type
        Update: UpdateEntityInput; // UPDATE input type
      };
    };
  };
};

export type Entity = Database["public"]["Tables"]["entities"]["Row"];
export type CreateEntityInput = Database["public"]["Tables"]["entities"]["Insert"];
export type UpdateEntityInput = Database["public"]["Tables"]["entities"]["Update"];
```

**Generate types after migrations:**
```bash
npx supabase gen types typescript --project-id <project-id> > types/database.ts
```

**API Types:**
```typescript
// types/api.ts

export interface ApiResponse<T> {
  data: T;
  error: string | null;
  status: number;
}

export interface PaginatedResponse<T> {
  items: T[];
  total: number;
  page: number;
  pageSize: number;
}
```

**DO:**
- ✅ Always generate types from database schema
- ✅ Use strict TypeScript mode
- ✅ Define interfaces for all props
- ✅ Use enums for fixed values
- ✅ Never use `any` (use `unknown` if truly needed)

---

### 11. NAMING CONVENTIONS

**Files:**
- Components: PascalCase (`EntityList.tsx`)
- Hooks: camelCase with `use` prefix (`useEntities.ts`)
- Services: camelCase with `Service` suffix (`entityService.ts`)
- Stores: camelCase with `Store` suffix (`entitiesStore.ts`)
- Types: camelCase (`database.ts`, `api.ts`)
- Constants: camelCase (`colors.ts`)

**Variables:**
- Components: PascalCase (`const EntityList = () => {}`)
- Functions: camelCase (`function getEntities()`)
- Constants: SCREAMING_SNAKE_CASE for true constants (`const API_URL`)
- State variables: camelCase (`const [entities, setEntities]`)

**Database:**
- Tables: snake_case, plural (`user_loadouts`, `weapon_models`)
- Columns: snake_case (`created_by`, `organization_id`)
- Indexes: `idx_[table]_[column]` (`idx_sessions_organization_id`)

---

### 12. MIGRATION CHECKLIST

When adding a new feature:

**1. Database Schema** (`supabase/migrations/[timestamp]_[name].sql`)
- [ ] Create table with proper columns
- [ ] Add `organization_id` and `created_by` columns
- [ ] Add `created_at` and `updated_at` with trigger
- [ ] Add foreign key constraints with `ON DELETE CASCADE`
- [ ] Create indexes for foreign keys
- [ ] Enable RLS
- [ ] Add RLS policies (SELECT, INSERT, UPDATE, DELETE)
- [ ] Add seed data if needed (`supabase/seed.sql`)

**2. Generate Types**
- [ ] Run `npx supabase gen types` to update `types/database.ts`

**3. Service Layer** (`services/[entity]Service.ts`)
- [ ] Create `get[Entity]Service(userId, orgId)`
- [ ] Create `create[Entity]Service(input, userId, orgId)`
- [ ] Create `update[Entity]Service(id, input)`
- [ ] Create `delete[Entity]Service(id)`
- [ ] Add JSDoc comments
- [ ] Add error handling
- [ ] Export all functions

**4. State Management** (`store/[entity]Store.ts`)
- [ ] Define state interface
- [ ] Create Zustand store
- [ ] Add `fetch`, `create`, `update`, `delete` actions
- [ ] Add `reset` action
- [ ] Add loading/error handling
- [ ] Call service functions

**5. Hooks** (`hooks/services/use[Entity].ts`) - Optional
- [ ] Create hook wrapper if needed for simple queries
- [ ] Use service functions
- [ ] Return loading/error/data/refetch

**6. Components** (`modules/[feature]/components/`)
- [ ] Create feature components
- [ ] Use stores or hooks for data
- [ ] Handle loading/error states
- [ ] Add proper TypeScript types

**7. Test**
- [ ] Test personal context (no orgId)
- [ ] Test organization context (with orgId)
- [ ] Test RLS policies work correctly
- [ ] Test error handling

---

### 13. FORBIDDEN PATTERNS (DON'T DO THIS)

❌ **Passing tokens to services:**
```typescript
// DON'T
getSessionsService(token, userId, orgId);
```

❌ **Direct Supabase client in components:**
```typescript
// DON'T
const client = await getAuthenticatedClient();
const { data } = await client.from("sessions").select();
```

❌ **Business logic in components:**
```typescript
// DON'T
const handleCreate = async () => {
  const client = await getAuthenticatedClient();
  const { data } = await client.from("sessions").insert({ ... });
  // ... lots of logic
};
```

❌ **Mixed patterns (direct DB + service layer):**
```typescript
// DON'T - Pick one pattern
const sessions = await getSessionsService(userId); // Service
const trainings = await client.from("trainings").select(); // Direct
```

❌ **Ignoring errors:**
```typescript
// DON'T
try {
  await createEntity();
} catch (error) {
  // Silent failure
}
```

❌ **Using `any` types:**
```typescript
// DON'T
function processData(data: any) { ... }
```

❌ **Giant god stores:**
```typescript
// DON'T
const appStore = create(() => ({
  sessions: [],
  trainings: [],
  users: [],
  organizations: [],
  // ... everything
}));
```

---

### 14. QUICK REFERENCE

**Need to fetch data?**
→ Create service function → Call from hook or store

**Need shared state?**
→ Create Zustand store → Use in components

**Need component-specific data?**
→ Create custom hook wrapping service function

**Need to add new table?**
→ Follow migration checklist (Section 12)

**Getting auth errors?**
→ Check RLS policies → Verify JWT token has correct claims

**Need organization context?**
→ Use `const { orgId } = useAuth()` → Pass to service functions

**Data not updating?**
→ Check store is calling service → Verify RLS allows operation

---

### 15. CLERK AUTHENTICATION SETUP

**Required Configuration:**
1. Create "supabase" JWT template in Clerk dashboard
2. Include claims: `sub` (user_id), `org_id`, `role`, `org_role`
3. Initialize AuthenticatedClient in EnhancedAuthProvider
4. Wrap app with ClerkProvider and EnhancedAuthProvider

**Usage:**
```typescript
import { useAuth } from "@/hooks/useAuth";

const { userId, orgId, isLoaded, isSignedIn } = useAuth();
```

---

## Summary

**Golden Rules:**
1. Services handle ALL database operations
2. AuthenticatedClient automatically injects tokens
3. Stores manage shared state, hooks for component-specific
4. RLS policies enforce permissions at database level
5. Context-based filtering (personal vs organization)
6. Strong TypeScript types throughout
7. Consistent error handling with custom error types
8. Follow migration checklist for new features

**When in doubt:**
- Refer to existing patterns in `sessionService.ts`, `sessionsStore.ts`
- Use service layer pattern consistently
- Keep components simple and focused
- Let RLS handle permission enforcement
- Test both personal and organization contexts
